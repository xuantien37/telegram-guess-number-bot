import os
import random
import json
import asyncio
import logging
from datetime import datetime, timedelta
from telegram import Update, InlineKeyboardButton, InlineKeyboardMarkup
from telegram.ext import (
    ApplicationBuilder, CommandHandler, MessageHandler, CallbackQueryHandler,
    ContextTypes, filters
)

# ========== C·∫§U H√åNH ==========
TOKEN = os.getenv("BOT_TOKEN")
if not TOKEN:
    raise ValueError("Vui l√≤ng cung c·∫•p BOT_TOKEN trong bi·∫øn m√¥i tr∆∞·ªùng")

SCORE_FILE = 'score_data.json'
TIMEOUT_SECONDS = 300  # 5 ph√∫t
DAILY_REWARD_BASE = 20
MAX_DAILY_STREAK = 7

# C·∫•u h√¨nh logging
logging.basicConfig(
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s',
    level=logging.INFO
)
logger = logging.getLogger(__name__)

# ========== TR·∫†NG TH√ÅI TR√í CH∆†I ==========
user_games = {}
players_data = {}
pvp_challenges = {}

# ========== X·ª¨ L√ù D·ªÆ LI·ªÜU ==========
def load_data():
    global players_data
    try:
        if os.path.exists(SCORE_FILE):
            with open(SCORE_FILE, 'r') as f:
                players_data = json.load(f)
    except Exception as e:
        logger.error(f"L·ªói khi ƒë·ªçc file d·ªØ li·ªáu: {e}")
        players_data = {}

def save_data():
    try:
        with open(SCORE_FILE, 'w') as f:
            json.dump(players_data, f, indent=2)
    except Exception as e:
        logger.error(f"L·ªói khi l∆∞u file d·ªØ li·ªáu: {e}")

def get_player(uid):
    uid_str = str(uid)
    if uid_str not in players_data:
        players_data[uid_str] = {
            "score": 0,
            "wins": 0,
            "losses": 0,
            "games_played": 0,
            "inventory": {},
            "current_streak": 0,
            "max_streak": 0,
            "last_reward_date": None,
            "reward_streak": 0,
            "completed_quests": {},
            "pvp_wins": 0,
            "pvp_losses": 0
        }
    return players_data[uid_str]

# ========== ƒê·ªò KH√ì TR√í CH∆†I ==========
def get_level(score):
    if score < 100: return 1
    elif score < 300: return 2
    elif score < 600: return 3
    elif score < 1000: return 4
    elif score < 1500: return 5
    elif score < 2500: return 6
    return 7

def get_difficulty(level):
    return {
        1: {"range": (1, 50), "attempts": 7, "penalty": 5},
        2: {"range": (1, 100), "attempts": 6, "penalty": 10},
        3: {"range": (1, 200), "attempts": 6, "penalty": 15},
        4: {"range": (1, 300), "attempts": 5, "penalty": 20},
        5: {"range": (1, 500), "attempts": 5, "penalty": 25},
        6: {"range": (1, 750), "attempts": 4, "penalty": 30},
        7: {"range": (1, 1000), "attempts": 4, "penalty": 40},
    }[level]

# ========== C·ª¨A H√ÄNG ==========
SHOP_ITEMS = {
    "extra_attempt": {"price": 30, "desc": "+1 l∆∞·ª£t ƒëo√°n", "type": "game"},
    "hint_type": {"price": 20, "desc": "G·ª£i √Ω ch·∫µn/l·∫ª", "type": "hint"},
    "hint_range": {"price": 40, "desc": "G·ª£i √Ω kho·∫£ng ¬±50", "type": "hint"},
    "change_secret": {"price": 50, "desc": "ƒê·ªïi s·ªë b√≠ m·∫≠t", "type": "game"},
    "streak_protector": {"price": 100, "desc": "B·∫£o v·ªá streak khi thua", "type": "bonus"},
    "double_points": {"price": 150, "desc": "Nh·∫≠n 2x ƒëi·ªÉm trong 3 v√°n", "type": "bonus"},
}

# ========== NHI·ªÜM V·ª§ ==========
QUESTS = {
    "win_3_games": {"goal": 3, "reward": 50, "desc": "Th·∫Øng 3 tr√≤ ch∆°i"},
    "reach_1000": {"goal": 1000, "reward": 100, "desc": "ƒê·∫°t 1000 ƒëi·ªÉm"},
    "win_5_pvp": {"goal": 5, "reward": 150, "desc": "Th·∫Øng 5 tr·∫≠n PvP"},
    "daily_streak_7": {"goal": 7, "reward": 200, "desc": "Nh·∫≠n qu√† 7 ng√†y li√™n ti·∫øp"},
}

# ========== H·ªÜ TH·ªêNG PvP ==========
class PvPGame:
    def __init__(self, challenger_id, opponent_id, difficulty):
        self.challenger_id = challenger_id
        self.opponent_id = opponent_id
        self.difficulty = difficulty
        self.secret = random.randint(*difficulty["range"])
        self.challenger_attempts = 0
        self.opponent_attempts = 0
        self.max_attempts = difficulty["attempts"]
        self.winner = None
        self.start_time = datetime.now()
        
    def make_guess(self, player_id, guess):
        if player_id == self.challenger_id:
            self.challenger_attempts += 1
        else:
            self.opponent_attempts += 1
            
        if guess == self.secret:
            self.winner = player_id
            return "win"
        elif guess < self.secret:
            return "higher"
        else:
            return "lower"

# ========== T√çNH ƒêI·ªÇM ==========
def calculate_points(attempts_used, max_attempts, streak=0, difficulty_level=1, is_pvp=False):
    base_points = max(10, (100 - attempts_used * 10) * difficulty_level)
    streak_bonus = streak * 5
    
    # ƒêi·ªÉm th∆∞·ªüng cho PvP
    if is_pvp:
        base_points *= 1.5
    
    # √Åp d·ª•ng double points n·∫øu c√≥
    return int(base_points + streak_bonus)

# ========== KI·ªÇM TRA NHI·ªÜM V·ª§ ==========
async def check_quests(user_id, context, quest_type, progress):
    player = get_player(user_id)
    completed = False
    
    for quest_id, quest in QUESTS.items():
        if quest_id.startswith(quest_type):
            current_progress = player.get("quest_progress", {}).get(quest_id, 0)
            new_progress = min(current_progress + progress, quest["goal"])
            
            player.setdefault("quest_progress", {})[quest_id] = new_progress
            
            if new_progress >= quest["goal"] and not player.get("completed_quests", {}).get(quest_id, False):
                player["score"] += quest["reward"]
                player.setdefault("completed_quests", {})[quest_id] = True
                await context.bot.send_message(
                    chat_id=user_id,
                    text=f"üéØ Ho√†n th√†nh nhi·ªám v·ª•: {quest['desc']}! +{quest['reward']} ƒëi·ªÉm"
                )
                completed = True
                save_data()
    
    return completed

# ========== H·∫∏N GI·ªú ==========
async def timeout_game(user_id, context):
    await asyncio.sleep(TIMEOUT_SECONDS)
    if user_id in user_games:
        player = get_player(user_id)
        player["losses"] += 1
        player["current_streak"] = 0
        save_data()
        
        del user_games[user_id]
        await context.bot.send_message(
            chat_id=user_id,
            text="‚åõ H·∫øt th·ªùi gian! Tr√≤ ch∆°i k·∫øt th√∫c. G√µ /play ƒë·ªÉ b·∫Øt ƒë·∫ßu l·∫°i."
        )

async def timeout_pvp_game(game_id, context):
    await asyncio.sleep(TIMEOUT_SECONDS * 2)  # Th·ªùi gian d√†i h∆°n cho PvP
    if game_id in pvp_challenges:
        game = pvp_challenges[game_id]
        challenger = get_player(game.challenger_id)
        opponent = get_player(game.opponent_id)
        
        challenger["pvp_losses"] += 1
        opponent["pvp_losses"] += 1
        save_data()
        
        del pvp_challenges[game_id]
        await context.bot.send_message(
            chat_id=game.challenger_id,
            text="‚åõ Tr·∫≠n ƒë·∫•u PvP ƒë√£ h·∫øt th·ªùi gian m√† kh√¥ng c√≥ ng∆∞·ªùi chi·∫øn th·∫Øng!"
        )
        await context.bot.send_message(
            chat_id=game.opponent_id,
            text="‚åõ Tr·∫≠n ƒë·∫•u PvP ƒë√£ h·∫øt th·ªùi gian m√† kh√¥ng c√≥ ng∆∞·ªùi chi·∫øn th·∫Øng!"
        )

# ========== L·ªÜNH C∆† B·∫¢N ==========
async def start(update: Update, context: ContextTypes.DEFAULT_TYPE):
    user = update.effective_user
    await update.message.reply_text(
        f"üëã Ch√†o {user.first_name}! T√¥i l√† bot ƒëo√°n s·ªë th√¥ng minh.\n\n"
        "üéÆ C√°c l·ªánh ch√≠nh:\n"
        "/play - B·∫Øt ƒë·∫ßu tr√≤ ch∆°i m·ªõi\n"
        "/pvp - Th√°ch ƒë·∫•u ng∆∞·ªùi kh√°c\n"
        "/shop - C·ª≠a h√†ng v·∫≠t ph·∫©m\n"
        "/daily - Nh·∫≠n qu√† h√†ng ng√†y\n"
        "/leaderboard - B·∫£ng x·∫øp h·∫°ng\n"
        "/stats - Th·ªëng k√™ c√° nh√¢n"
    )

# ========== TR√í CH∆†I CH√çNH ==========
async def play(update: Update, context: ContextTypes.DEFAULT_TYPE):
    user_id = update.effective_user.id
    
    if user_id in user_games:
        await update.message.reply_text("‚ö†Ô∏è B·∫°n ƒëang c√≥ tr√≤ ch∆°i ho·∫°t ƒë·ªông! G√µ /giveup n·∫øu mu·ªën b·ªè cu·ªôc.")
        return
    
    player = get_player(user_id)
    level = get_level(player["score"])
    diff = get_difficulty(level)
    
    # T·∫°o s·ªë b√≠ m·∫≠t tr√°nh c√°c s·ªë g·∫ßn bi√™n
    secret = random.randint(
        diff["range"][0] + int(0.1 * (diff["range"][1] - diff["range"][0])),
        diff["range"][1] - int(0.1 * (diff["range"][1] - diff["range"][0]))
    )
    
    task = asyncio.create_task(timeout_game(user_id, context))
    user_games[user_id] = {
        "secret": secret,
        "attempts": 0,
        "max_attempts": diff["attempts"],
        "range": diff["range"],
        "timeout_task": task,
        "level": level,
        "start_time": datetime.now(),
        "used_hints": []
    }
    
    await update.message.reply_text(
        f"üéÆ B·∫Øt ƒë·∫ßu tr√≤ ch∆°i c·∫•p {level}!\n"
        f"üî¢ Ph·∫°m vi s·ªë: {diff['range'][0]} - {diff['range'][1]}\n"
        f"üí° S·ªë l∆∞·ª£t ƒëo√°n: {diff['attempts']}\n\n"
        f"G·ª≠i s·ªë b·∫°n ƒëo√°n ngay b√¢y gi·ªù!"
    )

async def handle_guess(update: Update, context: ContextTypes.DEFAULT_TYPE):
    user_id = update.effective_user.id
    message = update.message.text.strip()
    
    if user_id not in user_games:
        await update.message.reply_text("‚ö†Ô∏è G√µ /play ƒë·ªÉ b·∫Øt ƒë·∫ßu tr√≤ ch∆°i.")
        return
    
    if not message.isdigit():
        await update.message.reply_text("‚ùå Vui l√≤ng nh·∫≠p m·ªôt s·ªë nguy√™n.")
        return
    
    guess = int(message)
    game = user_games[user_id]
    player = get_player(user_id)
    secret = game["secret"]
    game["attempts"] += 1
    
    # Ki·ªÉm tra xem c√≥ double points kh√¥ng
    is_double_points = "double_points" in player.get("active_bonuses", {})
    
    if guess < secret:
        await update.message.reply_text(
            f"üîº Cao h∆°n! ({game['max_attempts'] - game['attempts']} l∆∞·ª£t c√≤n l·∫°i)" +
            (" üéØ 2x ƒêI·ªÇM!" if is_double_points else "")
        )
    elif guess > secret:
        await update.message.reply_text(
            f"üîΩ Th·∫•p h∆°n! ({game['max_attempts'] - game['attempts']} l∆∞·ª£t c√≤n l·∫°i)" +
            (" üéØ 2x ƒêI·ªÇM!" if is_double_points else "")
        )
    else:
        # X·ª≠ l√Ω khi ƒëo√°n ƒë√∫ng
        points = calculate_points(
            game["attempts"],
            game["max_attempts"],
            player.get("current_streak", 0),
            game["level"]
        )
        
        if is_double_points:
            points *= 2
            player["active_bonuses"]["double_points"] -= 1
            if player["active_bonuses"]["double_points"] <= 0:
                del player["active_bonuses"]["double_points"]
        
        player["score"] += points
        player["wins"] += 1
        player["games_played"] += 1
        player["current_streak"] = player.get("current_streak", 0) + 1
        player["max_streak"] = max(player.get("max_streak", 0), player["current_streak"])
        player["last_win_time"] = datetime.now().isoformat()
        
        # Ki·ªÉm tra nhi·ªám v·ª•
        await check_quests(user_id, context, "win_games", 1)
        
        game["timeout_task"].cancel()
        del user_games[user_id]
        save_data()
        
        await update.message.reply_text(
            f"üéâ Ch√≠nh x√°c! S·ªë l√† {secret}.\n"
            f"üèÜ ƒêi·ªÉm: +{points} | T·ªïng: {player['score']}\n"
            f"üî• Streak: {player['current_streak']}\n"
            f"‚è≥ B·∫Øt ƒë·∫ßu v√°n m·ªõi sau 3 gi√¢y..."
        )
        
        await asyncio.sleep(3)
        await play(update, context)
        return
    
    if game["attempts"] >= game["max_attempts"]:
        # X·ª≠ l√Ω khi h·∫øt l∆∞·ª£t
        penalty = game.get("penalty", 20)
        
        # Ki·ªÉm tra streak protector
        if "streak_protector" in player.get("inventory", {}) and player["inventory"]["streak_protector"] > 0:
            player["inventory"]["streak_protector"] -= 1
            penalty = 0
            await update.message.reply_text("üõ°Ô∏è B·∫°n ƒë√£ s·ª≠ d·ª•ng streak protector!")
        else:
            player["current_streak"] = 0
        
        player["score"] = max(0, player["score"] - penalty)
        player["losses"] += 1
        player["games_played"] += 1
        save_data()
        
        await update.message.reply_text(
            f"üò¢ B·∫°n ƒë√£ h·∫øt l∆∞·ª£t. S·ªë ƒë√∫ng l√† {secret}.\n"
            f"‚ùå Tr·ª´ {penalty} ƒëi·ªÉm. T·ªïng ƒëi·ªÉm: {player['score']}\n"
            f"üîÅ G√µ /play ƒë·ªÉ ch∆°i l·∫°i."
        )
        
        game["timeout_task"].cancel()
        del user_games[user_id]

# ========== TR√í CH∆†I PvP ==========
async def pvp(update: Update, context: ContextTypes.DEFAULT_TYPE):
    user_id = update.effective_user.id
    
    if len(context.args) < 1:
        await update.message.reply_text(
            "üéÆ Ch·∫ø ƒë·ªô PvP - Th√°ch ƒë·∫•u ng∆∞·ªùi kh√°c\n\n"
            "C√°ch s·ª≠ d·ª•ng:\n"
            "/pvp @username - Th√°ch ƒë·∫•u ng∆∞·ªùi ch∆°i kh√°c\n"
            "/pvp accept - Ch·∫•p nh·∫≠n th√°ch ƒë·∫•u\n"
            "/pvp cancel - H·ªßy th√°ch ƒë·∫•u"
        )
        return
    
    if context.args[0] == "accept":
        if user_id not in pvp_challenges:
            await update.message.reply_text("‚ö†Ô∏è Kh√¥ng c√≥ l·ªùi m·ªùi PvP n√†o ƒëang ch·ªù b·∫°n.")
            return
            
        game_id, challenge = next((k, v) for k, v in pvp_challenges.items() if v.opponent_id == user_id)
        challenger_id = challenge.challenger_id
        
        # T·∫°o game PvP
        level = min(
            get_level(get_player(challenger_id)["score"]),
            get_level(get_player(user_id)["score"])
        )
        diff = get_difficulty(level)
        
        pvp_game = PvPGame(challenger_id, user_id, diff)
        pvp_challenges[game_id] = pvp_game
        task = asyncio.create_task(timeout_pvp_game(game_id, context))
        
        await context.bot.send_message(
            chat_id=challenger_id,
            text=f"üéÆ Tr·∫≠n ƒë·∫•u PvP ƒë√£ b·∫Øt ƒë·∫ßu!\n"
                 f"üî¢ Ph·∫°m vi s·ªë: {diff['range'][0]} - {diff['range'][1]}\n"
                 f"üí° S·ªë l∆∞·ª£t ƒëo√°n m·ªói ng∆∞·ªùi: {diff['attempts']}\n\n"
                 f"G·ª≠i s·ªë b·∫°n ƒëo√°n ngay b√¢y gi·ªù!"
        )
        
        await context.bot.send_message(
            chat_id=user_id,
            text=f"üéÆ Tr·∫≠n ƒë·∫•u PvP ƒë√£ b·∫Øt ƒë·∫ßu!\n"
                 f"üî¢ Ph·∫°m vi s·ªë: {diff['range'][0]} - {diff['range'][1]}\n"
                 f"üí° S·ªë l∆∞·ª£t ƒëo√°n m·ªói ng∆∞·ªùi: {diff['attempts']}\n\n"
                 f"G·ª≠i s·ªë b·∫°n ƒëo√°n ngay b√¢y gi·ªù!"
        )
        
        return
    
    elif context.args[0] == "cancel":
        # H·ªßy th√°ch ƒë·∫•u
        pass
    
    else:
        # Th√°ch ƒë·∫•u ng∆∞·ªùi kh√°c
        pass

# ========== C·ª¨A H√ÄNG ==========
async def show_shop(update: Update, context: ContextTypes.DEFAULT_TYPE):
    user_id = update.effective_user.id
    player = get_player(user_id)
    
    keyboard = [
        [InlineKeyboardButton("V·∫≠t ph·∫©m tr√≤ ch∆°i", callback_data="shop_game")],
        [InlineKeyboardButton("G·ª£i √Ω", callback_data="shop_hint")],
        [InlineKeyboardButton("Bonus", callback_data="shop_bonus")],
    ]
    
    reply_markup = InlineKeyboardMarkup(keyboard)
    
    await update.message.reply_text(
        f"üõí C·ª¨A H√ÄNG - ƒêi·ªÉm hi·ªán c√≥: {player['score']}\n"
        "Ch·ªçn danh m·ª•c:",
        reply_markup=reply_markup
    )

async def shop_category(update: Update, context: ContextTypes.DEFAULT_TYPE):
    query = update.callback_query
    await query.answer()
    
    user_id = query.from_user.id
    player = get_player(user_id)
    category = query.data.split("_")[1]
    
    items = {k: v for k, v in SHOP_ITEMS.items() if v["type"] == category}
    
    if not items:
        await query.edit_message_text("‚ö†Ô∏è Kh√¥ng c√≥ v·∫≠t ph·∫©m n√†o trong danh m·ª•c n√†y.")
        return
    
    buttons = []
    for item_id, item in items.items():
        buttons.append([
            InlineKeyboardButton(
                f"{item['desc']} - {item['price']} ƒëi·ªÉm",
                callback_data=f"buy_{item_id}"
            )
        ])
    
    buttons.append([InlineKeyboardButton("üîô Quay l·∫°i", callback_data="shop_back")])
    
    await query.edit_message_text(
        f"üõí Danh m·ª•c {category.capitalize()} - ƒêi·ªÉm hi·ªán c√≥: {player['score']}",
        reply_markup=InlineKeyboardMarkup(buttons)
    )

async def buy_item(update: Update, context: ContextTypes.DEFAULT_TYPE):
    query = update.callback_query
    await query.answer()
    
    user_id = query.from_user.id
    item_id = query.data.split("_")[1]
    player = get_player(user_id)
    
    if item_id not in SHOP_ITEMS:
        await query.edit_message_text("‚ö†Ô∏è V·∫≠t ph·∫©m kh√¥ng t·ªìn t·∫°i.")
        return
    
    item = SHOP_ITEMS[item_id]
    
    if player["score"] < item["price"]:
        await query.edit_message_text("‚ùå B·∫°n kh√¥ng ƒë·ªß ƒëi·ªÉm ƒë·ªÉ mua v·∫≠t ph·∫©m n√†y.")
        return
    
    player["score"] -= item["price"]
    player["inventory"][item_id] = player["inventory"].get(item_id, 0) + 1
    
    # X·ª≠ l√Ω v·∫≠t ph·∫©m ƒë·∫∑c bi·ªát
    if item_id == "double_points":
        player.setdefault("active_bonuses", {})["double_points"] = 3
    
    save_data()
    
    await query.edit_message_text(
        f"‚úÖ ƒê√£ mua {item['desc']} th√†nh c√¥ng!\n"
        f"üí∞ ƒêi·ªÉm c√≤n l·∫°i: {player['score']}"
    )

# ========== QU√Ä H√ÄNG NG√ÄY ==========
async def daily_reward(update: Update, context: ContextTypes.DEFAULT_TYPE):
    user_id = update.effective_user.id
    player = get_player(user_id)
    
    today = datetime.now().date().isoformat()
    last_reward = player.get("last_reward_date")
    
    if last_reward == today:
        await update.message.reply_text("‚ö†Ô∏è B·∫°n ƒë√£ nh·∫≠n qu√† h√¥m nay r·ªìi!")
        return
    
    # T√≠nh streak
    yesterday = (datetime.now() - timedelta(days=1)).date().isoformat()
    if last_reward == yesterday:
        streak = player.get("reward_streak", 0) + 1
    else:
        streak = 1
    
    # T√≠nh ƒëi·ªÉm th∆∞·ªüng
    reward = DAILY_REWARD_BASE + min(streak * 5, DAILY_REWARD_BASE * 2)
    player["score"] += reward
    player["last_reward_date"] = today
    player["reward_streak"] = streak
    
    # Ki·ªÉm tra nhi·ªám v·ª• streak
    await check_quests(user_id, context, "daily_streak", 1)
    
    save_data()
    
    await update.message.reply_text(
        f"üéÅ Nh·∫≠n {reward} ƒëi·ªÉm th∆∞·ªüng h√†ng ng√†y!\n"
        f"üî• Streak nh·∫≠n qu√†: {streak} ng√†y\n"
        f"üí∞ T·ªïng ƒëi·ªÉm: {player['score']}"
    )

# ========== TH·ªêNG K√ä ==========
async def show_stats(update: Update, context: ContextTypes.DEFAULT_TYPE):
    user_id = update.effective_user.id
    player = get_player(user_id)
    
    win_rate = (player["wins"] / player["games_played"] * 100) if player["games_played"] > 0 else 0
    pvp_win_rate = (player["pvp_wins"] / (player["pvp_wins"] + player["pvp_losses"]) * 100) if (player["pvp_wins"] + player["pvp_losses"]) > 0 else 0
    
    await update.message.reply_text(
        f"üìä TH·ªêNG K√ä C√Å NH√ÇN\n\n"
        f"üèÜ ƒêi·ªÉm: {player['score']} (C·∫•p {get_level(player['score'])})\n"
        f"üéÆ T·ªïng v√°n ch∆°i: {player['games_played']}\n"
        f"‚úÖ Th·∫Øng: {player['wins']} | ‚ùå Thua: {player['losses']} | üìà T·ªâ l·ªá: {win_rate:.1f}%\n"
        f"üî• Streak hi·ªán t·∫°i: {player.get('current_streak', 0)} | üèÖ Max streak: {player.get('max_streak', 0)}\n\n"
        f"‚öîÔ∏è PvP:\n"
        f"ü•á Th·∫Øng: {player.get('pvp_wins', 0)} | ü•à Thua: {player.get('pvp_losses', 0)} | üìà T·ªâ l·ªá: {pvp_win_rate:.1f}%\n\n"
        f"üéí V·∫≠t ph·∫©m: {sum(player.get('inventory', {}).values())}\n"
        f"üìÖ Streak nh·∫≠n qu√†: {player.get('reward_streak', 0)}/{MAX_DAILY_STREAK}"
    )

# ========== B·∫¢NG X·∫æP H·∫†NG ==========
async def leaderboard(update: Update, context: ContextTypes.DEFAULT_TYPE):
    # L·∫•y top 10 ng∆∞·ªùi ch∆°i
    top_players = sorted(
        [(uid, data) for uid, data in players_data.items() if "score" in data],
        key=lambda x: x[1]["score"],
        reverse=True
    )[:10]
    
    message = "üèÜ B·∫¢NG X·∫æP H·∫†NG TOP 10\n\n"
    for i, (uid, pdata) in enumerate(top_players, 1):
        try:
            user = await context.bot.get_chat(int(uid))
            name = user.username or user.first_name
        except:
            name = f"Ng∆∞·ªùi ch∆°i {uid[-4:]}"
        
        message += (
            f"{i}. {name} - {pdata['score']} ƒëi·ªÉm\n"
            f"   ‚úÖ {pdata.get('wins', 0)}W | "
            f"üî• {pdata.get('current_streak', 0)}S | "
            f"‚öîÔ∏è {pdata.get('pvp_wins', 0)}PvP\n"
        )
    
    await update.message.reply_text(message)

# ========== G·ª¢I √ù ==========
async def give_hint(update: Update, context: ContextTypes.DEFAULT_TYPE):
    user_id = update.effective_user.id
    
    if user_id not in user_games:
        await update.message.reply_text("‚ö†Ô∏è B·∫°n kh√¥ng c√≥ tr√≤ ch∆°i ƒëang ho·∫°t ƒë·ªông")
        return
    
    player = get_player(user_id)
    game = user_games[user_id]
    
    # Ki·ªÉm tra inventory
    if player["inventory"].get("hint_type", 0) > 0 and "type" not in game["used_hints"]:
        player["inventory"]["hint_type"] -= 1
        hint = "ch·∫µn" if game["secret"] % 2 == 0 else "l·∫ª"
        game["used_hints"].append("type")
        await update.message.reply_text(f"üí° G·ª£i √Ω: S·ªë l√† {hint}")
    elif player["inventory"].get("hint_range", 0) > 0 and "range" not in game["used_hints"]:
        player["inventory"]["hint_range"] -= 1
        secret = game["secret"]
        lower = max(game["range"][0], secret - 50)
        upper = min(game["range"][1], secret + 50)
        game["used_hints"].append("range")
        await update.message.reply_text(f"üí° G·ª£i √Ω: S·ªë n·∫±m trong kho·∫£ng {lower}-{upper}")
    else:
        await update.message.reply_text("‚ùå B·∫°n kh√¥ng c√≥ g·ª£i √Ω n√†o ho·∫∑c ƒë√£ s·ª≠ d·ª•ng h·∫øt. Mua t·∫°i /shop")
    
    save_data()

# ========== MAIN ==========
if __name__ == '__main__':
    load_data()
    
    app = ApplicationBuilder().token(TOKEN).build()
    
    # L·ªánh c∆° b·∫£n
    app.add_handler(CommandHandler("start", start))
    app.add_handler(CommandHandler("help", start))
    
    # L·ªánh tr√≤ ch∆°i
    app.add_handler(CommandHandler("play", play))
    app.add_handler(CommandHandler("pvp", pvp))
    app.add_handler(CommandHandler("hint", give_hint))
    app.add_handler(CommandHandler("giveup", give_up))
    
    # L·ªánh c·ª≠a h√†ng
    app.add_handler(CommandHandler("shop", show_shop))
    app.add_handler(CommandHandler("buy", buy_item))
    app.add_handler(CallbackQueryHandler(shop_category, pattern="^shop_"))
    app.add_handler(CallbackQueryHandler(buy_item, pattern="^buy_"))
    
    # L·ªánh th·ªëng k√™
    app.add_handler(CommandHandler("stats", show_stats))
    app.add_handler(CommandHandler("leaderboard", leaderboard))
    app.add_handler(CommandHandler("daily", daily_reward))
    
    # X·ª≠ l√Ω tin nh·∫Øn
    app.add_handler(MessageHandler(filters.TEXT & ~filters.COMMAND, handle_guess))
    
    logger.info("‚úÖ Bot ƒëang ch·∫°y...")
    app.run_polling()
